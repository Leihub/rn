{"version":3,"sources":["../../../server/utils/faker/enum.js"],"names":["field","db","getList","resolve","reject","times","values","collection","sourceRef","list","value","valueTpl","push","sep","join","mult","pickRef","data","sourceJson","Array","isArray","map","_id","k","text","d","pickJson","sourceType","pickEnum"],"mappings":";;;AAGA,oBAAuBA,KAAvB,EAA8BC,EAA9B,EAAkCC,OAAlC;AACS,sHAAY,iBAAOC,OAAP,EAAgBC,MAAhB;AACbC,6BADa,GACL,kBAAO,CAAP,CADK;AAEbC,8BAFa,GAEJ,EAFI;AAGVD,+BAHU;AAIIH,kCAAQD,GAAGM,UAAH,CAAcP,MAAMQ,SAApB,CAAR,EAAwC,EAAxC,EAA4C,CAA5C,EAA+C,EAA/C,CAJJ,SAITC,IAJS;AAKTC,6BALS,GAKD,yBAAWV,MAAMW,QAAN,IAAkB,OAA7B,EAAsC,eAAIF,KAAKA,IAAT,CAAtC,CALC;AAMfH,+BAAOM,IAAP,CAAYF,KAAZ,EANe;;AAQjBJ,iCAAS,oBAAW,kBAAQA,MAAR,CAAX,CAAT;AACA,4BAAIN,MAAMa,GAAV,EAAeP,SAASA,OAAOQ,IAAP,CAAYd,MAAMa,GAAlB,CAAT;AACfV,gCAAQH,MAAMe,IAAN,GAAaT,MAAb,GAAsBA,OAAO,CAAP,CAA9B,EAViB,gEAAZ,yEADT,kE,mBAAeU,O;;;;AAef,oBAAwBhB,KAAxB;AACS,kCAAY,UAACG,OAAD,EAAUC,MAAV,EAAqB;AACtC,kBAAIa,OAAOjB,MAAMkB,UAAjB;AACA,kBAAI,CAACC,MAAMC,OAAN,CAAcH,IAAd,CAAL,EAA0B;AACxBA,uBAAO,oBAAYA,IAAZ,EAAkBI,GAAlB,CAAsB,qBAAM;AACjCC,yBAAKC,CAD4B;AAEjCC,0BAAMP,KAAKM,CAAL,CAF2B,EAAN,EAAtB,CAAP;;AAID,eALD,MAKO;AACLN,uBAAOA,KAAKI,GAAL,CAAS,UAACI,CAAD,EAAO;AACrB,sBAAI,QAAOA,CAAP,uDAAOA,CAAP,OAAa,QAAjB,EAA2B,OAAOA,CAAP;AAC3B,yBAAO,EAAEH,KAAKG,CAAP,EAAP;AACD,iBAHM,CAAP;AAID;;AAED,kBAAIpB,QAAQ,kBAAO,CAAP,CAAZ;AACA,kBAAIC,SAAS,EAAb;AACA,qBAAOD,OAAP,EAAgB;AACd,oBAAMK,QAAQ,yBAAWV,MAAMW,QAAN,IAAkB,OAA7B,EAAsC,eAAIM,IAAJ,CAAtC,CAAd;AACAX,uBAAOM,IAAP,CAAYF,KAAZ;AACD;AACDJ,uBAAS,oBAAW,kBAAQA,MAAR,CAAX,CAAT;AACA,kBAAIN,MAAMa,GAAV,EAAeP,SAASA,OAAOQ,IAAP,CAAYd,MAAMa,GAAlB,CAAT;AACfV,sBAAQH,MAAMe,IAAN,GAAaT,MAAb,GAAsBA,OAAO,CAAP,CAA9B;AACD,aAvBM,CADT,kE,mBAAeoB,Q;;;AA2BR,oBAAwB1B,KAAxB,EAA+BC,EAA/B,EAAmCC,OAAnC;AACGyB,sBADH,GACkB3B,KADlB,CACG2B,UADH;AAEGA,sBAFH;AAGE,kBAHF;;AAKE,iBALF,iDAIYD,SAAS1B,KAAT,CAJZ;AAMYgB,sBAAQhB,KAAR,EAAeC,EAAf,EAAmBC,OAAnB,CANZ,4H,mBAAe0B,Q,2DA7CtB,8BACA,qC","file":"enum.js","sourcesContent":["import { one, random } from './pick'\nimport { substitute } from '../strings'\n\nasync function pickRef(field, db, getList) {\n  return new Promise(async (resolve, reject) => {\n    let times = random(3)\n    let values = []\n    while (times--) {\n      const list = await getList(db.collection(field.sourceRef), {}, 1, 20)\n      const value = substitute(field.valueTpl || '{_id}', one(list.list))\n      values.push(value)\n    }\n    values = Array.from(new Set(values))\n    if (field.sep) values = values.join(field.sep)\n    resolve(field.mult ? values : values[0])\n  })\n}\n\nasync function pickJson(field) {\n  return new Promise((resolve, reject) => {\n    let data = field.sourceJson\n    if (!Array.isArray(data)) {\n      data = Object.keys(data).map(k => ({\n        _id: k,\n        text: data[k],\n      }))\n    } else {\n      data = data.map((d) => {\n        if (typeof d === 'object') return d\n        return { _id: d }\n      })\n    }\n\n    let times = random(3)\n    let values = []\n    while (times--) {\n      const value = substitute(field.valueTpl || '{_id}', one(data))\n      values.push(value)\n    }\n    values = Array.from(new Set(values))\n    if (field.sep) values = values.join(field.sep)\n    resolve(field.mult ? values : values[0])\n  })\n}\n\nexport async function pickEnum(field, db, getList) {\n  const { sourceType } = field\n  switch (sourceType) {\n    case 'json':\n      return await pickJson(field)\n    case 'ref':\n      return await pickRef(field, db, getList)\n  }\n}\n"]}